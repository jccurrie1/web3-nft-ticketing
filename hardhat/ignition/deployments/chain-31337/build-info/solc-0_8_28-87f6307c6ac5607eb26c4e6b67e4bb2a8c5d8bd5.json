{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-87f6307c6ac5607eb26c4e6b67e4bb2a8c5d8bd5",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EventTicket.sol": "project/contracts/EventTicket.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/EventTicket.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\n/**\n * @title EventTicket\n * @dev An on-chain NFT ticketing system for games and events\n * @notice All event and ticket data is stored on-chain\n */\ncontract EventTicket {\n    // Event structure to store event information on-chain\n    struct Event {\n        uint256 eventId;\n        string name;\n        string description;\n        uint256 eventDate;\n        string venue;\n        address creator;\n        uint256 totalTickets;\n        uint256 ticketsSold;\n        uint256 price; // Price in wei\n        bool isActive;\n    }\n\n    // Ticket structure to store ticket information on-chain\n    struct Ticket {\n        uint256 ticketId;\n        uint256 eventId;\n        address owner;\n        uint256 purchasePrice;\n        uint256 purchaseTime;\n        bool isValid;\n    }\n\n    // Mapping from event ID to Event\n    mapping(uint256 => Event) public events;\n\n    // Mapping from ticket ID to Ticket\n    mapping(uint256 => Ticket) public tickets;\n\n    // Mapping from event ID to array of ticket IDs\n    mapping(uint256 => uint256[]) public eventTickets;\n\n    // Mapping from owner address to array of ticket IDs they own\n    mapping(address => uint256[]) public ownerTickets;\n\n    // Mapping from owner to ticket count\n    mapping(address => uint256) public balanceOf;\n\n    // Mapping from ticket ID to approved address\n    mapping(uint256 => address) public getApproved;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    // Total number of events created\n    uint256 public totalEvents;\n\n    // Total number of tickets minted\n    uint256 public totalTickets;\n\n    // Events\n    event EventCreated(\n        uint256 indexed eventId,\n        string name,\n        address indexed creator,\n        uint256 totalTickets,\n        uint256 price\n    );\n\n    event TicketMinted(\n        uint256 indexed ticketId,\n        uint256 indexed eventId,\n        address indexed owner,\n        uint256 price\n    );\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed ticketId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed ticketId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    // Modifiers\n    modifier onlyEventCreator(uint256 eventId) {\n        require(\n            events[eventId].creator == msg.sender,\n            \"Only event creator can perform this action\"\n        );\n        _;\n    }\n\n    modifier validEvent(uint256 eventId) {\n        require(\n            events[eventId].isActive,\n            \"Event does not exist or is not active\"\n        );\n        require(\n            events[eventId].ticketsSold < events[eventId].totalTickets,\n            \"Event is sold out\"\n        );\n        _;\n    }\n\n    modifier validTicket(uint256 ticketId) {\n        require(\n            tickets[ticketId].isValid,\n            \"Ticket does not exist or is invalid\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Create a new event\n     * @param name Name of the event\n     * @param description Description of the event\n     * @param eventDate Unix timestamp of the event date\n     * @param venue Venue location\n     * @param totalTickets Total number of tickets available\n     * @param price Price per ticket in wei\n     */\n    function createEvent(\n        string memory name,\n        string memory description,\n        uint256 eventDate,\n        string memory venue,\n        uint256 totalTickets,\n        uint256 price\n    ) public returns (uint256) {\n        require(bytes(name).length > 0, \"Event name cannot be empty\");\n        require(totalTickets > 0, \"Must have at least one ticket\");\n        require(\n            eventDate > block.timestamp,\n            \"Event date must be in the future\"\n        );\n\n        totalEvents++;\n        uint256 eventId = totalEvents;\n\n        events[eventId] = Event({\n            eventId: eventId,\n            name: name,\n            description: description,\n            eventDate: eventDate,\n            venue: venue,\n            creator: msg.sender,\n            totalTickets: totalTickets,\n            ticketsSold: 0,\n            price: price,\n            isActive: true\n        });\n\n        emit EventCreated(eventId, name, msg.sender, totalTickets, price);\n        return eventId;\n    }\n\n    /**\n     * @dev Mint a ticket for an event\n     * @param eventId The ID of the event\n     * @param to The address to mint the ticket to\n     */\n    function mintTicket(\n        uint256 eventId,\n        address to\n    ) public payable validEvent(eventId) {\n        require(to != address(0), \"Cannot mint to zero address\");\n        require(msg.value >= events[eventId].price, \"Insufficient payment\");\n\n        // Refund excess payment\n        if (msg.value > events[eventId].price) {\n            (bool refundSuccess, ) = payable(msg.sender).call{\n                value: msg.value - events[eventId].price\n            }(\"\");\n            require(refundSuccess, \"Refund failed\");\n        }\n\n        // Transfer payment to event creator\n        (bool transferSuccess, ) = payable(events[eventId].creator).call{\n            value: events[eventId].price\n        }(\"\");\n        require(transferSuccess, \"Payment transfer failed\");\n\n        // Mint the ticket\n        totalTickets++;\n        uint256 ticketId = totalTickets;\n\n        tickets[ticketId] = Ticket({\n            ticketId: ticketId,\n            eventId: eventId,\n            owner: to,\n            purchasePrice: events[eventId].price,\n            purchaseTime: block.timestamp,\n            isValid: true\n        });\n\n        // Update event ticket count\n        events[eventId].ticketsSold++;\n        eventTickets[eventId].push(ticketId);\n        ownerTickets[to].push(ticketId);\n        balanceOf[to]++;\n\n        emit TicketMinted(ticketId, eventId, to, events[eventId].price);\n        emit Transfer(address(0), to, ticketId);\n    }\n\n    /**\n     * @dev Transfer a ticket to another address\n     * @param from The current owner\n     * @param to The new owner\n     * @param ticketId The ticket ID to transfer\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 ticketId\n    ) public validTicket(ticketId) {\n        require(\n            tickets[ticketId].owner == from,\n            \"Ticket not owned by from address\"\n        );\n        require(\n            msg.sender == from ||\n                msg.sender == getApproved[ticketId] ||\n                isApprovedForAll[from][msg.sender],\n            \"Not authorized to transfer\"\n        );\n        require(to != address(0), \"Cannot transfer to zero address\");\n\n        _transfer(from, to, ticketId);\n    }\n\n    /**\n     * @dev Safe transfer a ticket (checks if recipient can handle ERC721)\n     * @param from The current owner\n     * @param to The new owner\n     * @param ticketId The ticket ID to transfer\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 ticketId\n    ) public {\n        safeTransferFrom(from, to, ticketId, \"\");\n    }\n\n    /**\n     * @dev Safe transfer a ticket with data\n     * @param from The current owner\n     * @param to The new owner\n     * @param ticketId The ticket ID to transfer\n     * @param data Additional data\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 ticketId,\n        bytes memory data\n    ) public {\n        transferFrom(from, to, ticketId);\n        // In a full ERC721 implementation, we would check if recipient is a contract\n        // and call onERC721Received. For simplicity, we'll skip that here.\n    }\n\n    /**\n     * @dev Approve an address to transfer a specific ticket\n     * @param approved The address to approve\n     * @param ticketId The ticket ID\n     */\n    function approve(\n        address approved,\n        uint256 ticketId\n    ) public validTicket(ticketId) {\n        require(tickets[ticketId].owner == msg.sender, \"Not the ticket owner\");\n        getApproved[ticketId] = approved;\n        emit Approval(msg.sender, approved, ticketId);\n    }\n\n    /**\n     * @dev Approve or revoke approval for an operator\n     * @param operator The operator address\n     * @param approved Whether to approve or revoke\n     */\n    function setApprovalForAll(address operator, bool approved) public {\n        require(operator != msg.sender, \"Cannot approve self\");\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev Get the owner of a ticket\n     * @param ticketId The ticket ID\n     * @return The owner address\n     */\n    function ownerOf(\n        uint256 ticketId\n    ) public view validTicket(ticketId) returns (address) {\n        return tickets[ticketId].owner;\n    }\n\n    /**\n     * @dev Get event details\n     * @param eventId The event ID\n     * @return Event struct\n     */\n    function getEvent(uint256 eventId) public view returns (Event memory) {\n        return events[eventId];\n    }\n\n    /**\n     * @dev Get ticket details\n     * @param ticketId The ticket ID\n     * @return Ticket struct\n     */\n    function getTicket(uint256 ticketId) public view returns (Ticket memory) {\n        return tickets[ticketId];\n    }\n\n    /**\n     * @dev Get all ticket IDs for an event\n     * @param eventId The event ID\n     * @return Array of ticket IDs\n     */\n    function getEventTickets(\n        uint256 eventId\n    ) public view returns (uint256[] memory) {\n        return eventTickets[eventId];\n    }\n\n    /**\n     * @dev Get all ticket IDs owned by an address\n     * @param owner The owner address\n     * @return Array of ticket IDs\n     */\n    function getOwnerTickets(\n        address owner\n    ) public view returns (uint256[] memory) {\n        return ownerTickets[owner];\n    }\n\n    /**\n     * @dev Invalidate a ticket (e.g., after event or refund)\n     * @param ticketId The ticket ID to invalidate\n     */\n    function invalidateTicket(uint256 ticketId) public validTicket(ticketId) {\n        require(\n            tickets[ticketId].owner == msg.sender ||\n                events[tickets[ticketId].eventId].creator == msg.sender,\n            \"Not authorized to invalidate ticket\"\n        );\n        tickets[ticketId].isValid = false;\n    }\n\n    /**\n     * @dev Deactivate an event (stop selling tickets)\n     * @param eventId The event ID\n     */\n    function deactivateEvent(uint256 eventId) public onlyEventCreator(eventId) {\n        events[eventId].isActive = false;\n    }\n\n    /**\n     * @dev Internal transfer function\n     */\n    function _transfer(address from, address to, uint256 ticketId) internal {\n        // Remove from old owner's list\n        uint256[] storage fromTickets = ownerTickets[from];\n        for (uint256 i = 0; i < fromTickets.length; i++) {\n            if (fromTickets[i] == ticketId) {\n                fromTickets[i] = fromTickets[fromTickets.length - 1];\n                fromTickets.pop();\n                break;\n            }\n        }\n        balanceOf[from]--;\n\n        // Add to new owner's list\n        ownerTickets[to].push(ticketId);\n        balanceOf[to]++;\n\n        // Update ticket owner\n        tickets[ticketId].owner = to;\n        getApproved[ticketId] = address(0);\n\n        emit Transfer(from, to, ticketId);\n    }\n\n    /**\n     * @dev ERC721 Metadata support (simplified)\n     */\n    function name() public pure returns (string memory) {\n        return \"Event Ticket\";\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"TICKET\";\n    }\n\n    function tokenURI(\n        uint256 ticketId\n    ) public view validTicket(ticketId) returns (string memory) {\n        // Return a simple on-chain URI representation\n        // In production, you might want to generate a more detailed JSON\n        Ticket memory ticket = tickets[ticketId];\n        Event memory eventData = events[ticket.eventId];\n\n        return\n            string(\n                abi.encodePacked(\n                    \"Event: \",\n                    eventData.name,\n                    \" | Ticket ID: \",\n                    _uint2str(ticketId),\n                    \" | Owner: \",\n                    _address2str(ticket.owner)\n                )\n            );\n    }\n\n    // Helper functions for string conversion\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function _address2str(address _addr) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(_addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < 20; i++) {\n            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}\n"
      }
    }
  }
}